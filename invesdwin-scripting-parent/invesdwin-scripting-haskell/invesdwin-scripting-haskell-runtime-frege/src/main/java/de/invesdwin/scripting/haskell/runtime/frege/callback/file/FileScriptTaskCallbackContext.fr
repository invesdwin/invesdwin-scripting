import Data.JSON

data FregeEval = native de.invesdwin.scripting.haskell.runtime.frege.callback.file.FregeEval where
    native new :: () -> IO (MutableIO FregeEval)
    native eval :: MutableIO FregeEval -> String -> IO a
    
waitForFile :: File -> IO ()
waitForFile file = do
  exists <- file.exists
  if exists
     then pure ()
     else do
       Thread.sleep 1
       waitForFile file
       
    
param :: ToJSON a => a -> Value
param x = toJSON x

callback :: forall r. String -> [Value] -> IO r
callback method args = do
  let scriptTaskCallbackContextRequestPartFile = {SCRIPT_TASK_CALLBACK_CONTEXT_REQUEST_PART_FILE}
  let scriptTaskCallbackContextRequestFile = {SCRIPT_TASK_CALLBACK_CONTEXT_REQUEST_FILE}
  let scriptTaskCallbackContextResponseFile = {SCRIPT_TASK_CALLBACK_CONTEXT_RESPONSE_FILE}
  let message = method ++ ";" ++ show (toJSON args)

  writeFile scriptTaskCallbackContextRequestPartFile message

  let requestPartFile = File.new scriptTaskCallbackContextRequestPartFile
  let requestFile     = File.new scriptTaskCallbackContextRequestFile
  requestPartFile.renameTo requestFile

  let responseFile = File.new scriptTaskCallbackContextResponseFile
  waitForFile responseFile

  returnExpression <- readFile scriptTaskCallbackContextResponseFile
  responseFile.delete

  bridge <- FregeEval.new ()
  resultObj <- FregeEval.eval bridge returnExpression
  pure resultObj